package frr

import (
	"fmt"
	"net"
	"strings"

	"github.com/akam1o/arca-router/pkg/config"
	"github.com/akam1o/arca-router/pkg/vpp"
)

// GenerateFRRConfig generates complete FRR configuration from arca-router configuration.
// It converts arca-router config to FRR format, including interface name conversion.
func GenerateFRRConfig(cfg *config.Config) (*Config, error) {
	if cfg == nil {
		return nil, fmt.Errorf("config is nil")
	}

	// Get hostname from system config (may be empty if system is not configured)
	hostname := ""
	if cfg.System != nil {
		hostname = cfg.System.HostName
	}

	frrConfig := &Config{
		Hostname:         hostname,
		LogFile:          "/var/log/frr/frr.log",
		LogTimestamp:     true,
		InterfaceMapping: make(map[string]string),
	}

	// Build interface mapping (Junos name â†’ Linux name)
	if err := buildInterfaceMapping(cfg, frrConfig); err != nil {
		return nil, NewGenerateError("failed to build interface mapping", err)
	}

	// Convert BGP configuration
	if cfg.Protocols != nil && cfg.Protocols.BGP != nil {
		bgpConfig, err := convertBGPConfig(cfg, frrConfig.InterfaceMapping)
		if err != nil {
			return nil, NewGenerateError("failed to convert BGP configuration", err)
		}
		frrConfig.BGP = bgpConfig
	}

	// Convert OSPF configuration
	if cfg.Protocols != nil && cfg.Protocols.OSPF != nil {
		ospfConfig, err := convertOSPFConfig(cfg, frrConfig.InterfaceMapping)
		if err != nil {
			return nil, NewGenerateError("failed to convert OSPF configuration", err)
		}
		frrConfig.OSPF = ospfConfig
	}

	// Convert static routes
	if cfg.RoutingOptions != nil && len(cfg.RoutingOptions.StaticRoutes) > 0 {
		staticRoutes, err := convertStaticRoutes(cfg.RoutingOptions.StaticRoutes)
		if err != nil {
			return nil, NewGenerateError("failed to convert static routes", err)
		}
		frrConfig.StaticRoutes = staticRoutes
	}

	// Convert policy-options (prefix-lists, route-maps, and AS-path access-lists)
	if cfg.PolicyOptions != nil {
		prefixLists, routeMaps, asPathLists, err := convertPolicyOptions(cfg)
		if err != nil {
			return nil, NewGenerateError("failed to convert policy-options", err)
		}
		frrConfig.PrefixLists = prefixLists
		frrConfig.RouteMaps = routeMaps
		frrConfig.ASPathAccessLists = asPathLists
	}

	return frrConfig, nil
}

// GenerateFRRConfigFile generates the complete FRR configuration file content.
func GenerateFRRConfigFile(frrConfig *Config) (string, error) {
	if frrConfig == nil {
		return "", fmt.Errorf("FRR config is nil")
	}

	var b strings.Builder

	// Header
	b.WriteString("!\n")
	b.WriteString("! FRR configuration generated by arca-router\n")
	b.WriteString("!\n")

	// Hostname
	if frrConfig.Hostname != "" {
		b.WriteString(fmt.Sprintf("hostname %s\n", frrConfig.Hostname))
	}

	// Logging
	if frrConfig.LogFile != "" {
		b.WriteString(fmt.Sprintf("log file %s\n", frrConfig.LogFile))
	}
	if frrConfig.LogTimestamp {
		b.WriteString("log timestamp precision 3\n")
	}

	b.WriteString("!\n")

	// Static routes
	if len(frrConfig.StaticRoutes) > 0 {
		staticConfig, err := GenerateStaticRouteConfig(frrConfig.StaticRoutes)
		if err != nil {
			return "", err
		}
		b.WriteString(staticConfig)
	}

	// Prefix-lists
	if len(frrConfig.PrefixLists) > 0 {
		prefixListConfig, err := GeneratePrefixListConfig(frrConfig.PrefixLists)
		if err != nil {
			return "", err
		}
		b.WriteString(prefixListConfig)
	}

	// AS-path access-lists
	if len(frrConfig.ASPathAccessLists) > 0 {
		asPathConfig, err := GenerateASPathAccessListConfig(frrConfig.ASPathAccessLists)
		if err != nil {
			return "", err
		}
		b.WriteString(asPathConfig)
	}

	// Route-maps
	if len(frrConfig.RouteMaps) > 0 {
		routeMapConfig, err := GenerateRouteMapConfig(frrConfig.RouteMaps, frrConfig.PrefixLists)
		if err != nil {
			return "", err
		}
		b.WriteString(routeMapConfig)
	}

	// BGP configuration
	if frrConfig.BGP != nil {
		bgpConfig, err := GenerateBGPConfig(frrConfig.BGP)
		if err != nil {
			return "", err
		}
		b.WriteString(bgpConfig)
	}

	// OSPF configuration
	if frrConfig.OSPF != nil {
		ospfConfig, err := GenerateOSPFConfig(frrConfig.OSPF)
		if err != nil {
			return "", err
		}
		b.WriteString(ospfConfig)
	}

	// Footer
	b.WriteString("!\n")
	b.WriteString("line vty\n")
	b.WriteString("!\n")
	b.WriteString("end\n")

	return b.String(), nil
}

// buildInterfaceMapping creates a mapping from Junos interface names to Linux interface names.
func buildInterfaceMapping(cfg *config.Config, frrConfig *Config) error {
	for junosName := range cfg.Interfaces {
		linuxName, err := vpp.ConvertJunosToLinuxName(junosName)
		if err != nil {
			return fmt.Errorf("failed to convert interface name %s: %w", junosName, err)
		}
		frrConfig.InterfaceMapping[junosName] = linuxName
	}
	return nil
}

// convertBGPConfig converts arca-router BGP config to FRR BGP config.
func convertBGPConfig(cfg *config.Config, ifaceMapping map[string]string) (*BGPConfig, error) {
	arcaBGP := cfg.Protocols.BGP
	if arcaBGP == nil {
		return nil, nil
	}

	// Get AS number from routing-options
	if cfg.RoutingOptions == nil {
		return nil, fmt.Errorf("BGP requires routing-options to be configured")
	}
	asn := cfg.RoutingOptions.AutonomousSystem
	if asn == 0 {
		return nil, fmt.Errorf("BGP requires autonomous-system to be configured in routing-options")
	}

	frrBGP := &BGPConfig{
		ASN:         asn,
		RouterID:    cfg.RoutingOptions.RouterID,
		Neighbors:   make([]BGPNeighbor, 0),
		IPv4Unicast: false,
		IPv6Unicast: false,
	}

	// Convert BGP groups and neighbors
	for _, group := range arcaBGP.Groups {
		for _, neighbor := range group.Neighbors {
			frrNeighbor := BGPNeighbor{
				IP:       neighbor.IP,
				RemoteAS: neighbor.PeerAS,
			}

			// Add description (include group name)
			if neighbor.Description != "" {
				frrNeighbor.Description = neighbor.Description
			} else {
				frrNeighbor.Description = fmt.Sprintf("BGP peer in group %s", group.Type)
			}

			// Determine IPv4 or IPv6
			if isIPv6(neighbor.IP) {
				frrNeighbor.IsIPv6 = true
				frrBGP.IPv6Unicast = true
			} else {
				frrBGP.IPv4Unicast = true
			}

			// Convert update-source (local-address)
			// If LocalAddress is an IP, try to find the interface that has this IP
			// If not found, use the IP directly as update-source
			if neighbor.LocalAddress != "" {
				updateSource := neighbor.LocalAddress

				// Try to find interface with this local address
				for junosName, iface := range cfg.Interfaces {
					if hasIPAddress(iface, neighbor.LocalAddress) {
						// Found interface with this IP, use Linux interface name
						if linuxName, ok := ifaceMapping[junosName]; ok {
							updateSource = linuxName
							break
						}
					}
				}

				frrNeighbor.UpdateSource = updateSource
			}

			// Apply route-maps from group's import/export policies
			// Validate that referenced policies exist
			if group.Import != "" {
				if cfg.PolicyOptions == nil || cfg.PolicyOptions.PolicyStatements == nil {
					return nil, fmt.Errorf("BGP group references import policy '%s' but no policy-options are configured", group.Import)
				}
				if _, exists := cfg.PolicyOptions.PolicyStatements[group.Import]; !exists {
					return nil, fmt.Errorf("BGP group references import policy '%s' but policy-statement does not exist", group.Import)
				}
				frrNeighbor.RouteMapIn = group.Import
			}
			if group.Export != "" {
				if cfg.PolicyOptions == nil || cfg.PolicyOptions.PolicyStatements == nil {
					return nil, fmt.Errorf("BGP group references export policy '%s' but no policy-options are configured", group.Export)
				}
				if _, exists := cfg.PolicyOptions.PolicyStatements[group.Export]; !exists {
					return nil, fmt.Errorf("BGP group references export policy '%s' but policy-statement does not exist", group.Export)
				}
				frrNeighbor.RouteMapOut = group.Export
			}

			frrBGP.Neighbors = append(frrBGP.Neighbors, frrNeighbor)
		}
	}

	return frrBGP, nil
}

// convertOSPFConfig converts arca-router OSPF config to FRR OSPF config.
func convertOSPFConfig(cfg *config.Config, ifaceMapping map[string]string) (*OSPFConfig, error) {
	arcaOSPF := cfg.Protocols.OSPF
	if arcaOSPF == nil {
		return nil, nil
	}

	// Determine router-id priority: protocols ospf router-id > routing-options router-id
	routerID := arcaOSPF.RouterID
	if routerID == "" && cfg.RoutingOptions != nil {
		routerID = cfg.RoutingOptions.RouterID
	}

	if routerID == "" {
		return nil, fmt.Errorf("OSPF requires router-id (either in routing-options or protocols ospf)")
	}

	frrOSPF := &OSPFConfig{
		RouterID:   routerID,
		Networks:   make([]OSPFNetwork, 0),
		Interfaces: make([]OSPFInterface, 0),
		IsOSPFv3:   false, // Phase 2: OSPFv2 only
	}

	// Convert OSPF areas and interfaces
	for _, area := range arcaOSPF.Areas {
		for _, iface := range area.Interfaces {
			junosName := iface.Name

			// Convert Junos interface name to Linux name
			linuxName, ok := ifaceMapping[junosName]
			if !ok {
				return nil, fmt.Errorf("OSPF interface %s not found in interface mapping", junosName)
			}

			// Get interface prefix for network statement
			arcaIface, exists := cfg.Interfaces[junosName]
			if !exists {
				return nil, fmt.Errorf("OSPF interface %s not found in interfaces configuration", junosName)
			}

			// Add network statements for each address on this interface
			for _, unit := range arcaIface.Units {
				for familyName, family := range unit.Family {
					if familyName == "inet" {
						for _, addr := range family.Addresses {
							// Parse address to get network prefix
							_, ipnet, err := net.ParseCIDR(addr)
							if err != nil {
								continue // Skip invalid addresses
							}

							frrOSPF.Networks = append(frrOSPF.Networks, OSPFNetwork{
								Prefix: ipnet.String(),
								AreaID: area.AreaID,
							})
						}
					}
					// Phase 2: IPv6 (inet6) not supported yet
				}
			}

			// Add interface-specific configuration
			frrIface := OSPFInterface{
				Name:    linuxName,
				AreaID:  area.AreaID,
				Passive: iface.Passive,
				Metric:  iface.Metric,
			}

			// Set priority only if explicitly configured (>= 0 is valid, including 0 for DR non-participation)
			if iface.Priority >= 0 {
				priority := iface.Priority
				frrIface.Priority = &priority
			}

			frrOSPF.Interfaces = append(frrOSPF.Interfaces, frrIface)
		}
	}

	return frrOSPF, nil
}

// convertStaticRoutes converts arca-router static routes to FRR format.
func convertStaticRoutes(arcaRoutes []*config.StaticRoute) ([]StaticRoute, error) {
	frrRoutes := make([]StaticRoute, 0, len(arcaRoutes))

	for _, route := range arcaRoutes {
		frrRoute := StaticRoute{
			Prefix:   route.Prefix,
			NextHop:  route.NextHop,
			Distance: route.Distance,
		}

		// Determine IPv4 or IPv6 from prefix
		_, ipnet, err := net.ParseCIDR(route.Prefix)
		if err != nil {
			return nil, fmt.Errorf("invalid static route prefix %s: %w", route.Prefix, err)
		}

		// Check if IPv6
		if ipnet.IP.To4() == nil {
			frrRoute.IsIPv6 = true
		}

		frrRoutes = append(frrRoutes, frrRoute)
	}

	return frrRoutes, nil
}

// hasIPAddress checks if an interface has a specific IP address.
func hasIPAddress(iface *config.Interface, ipAddr string) bool {
	// Parse the target IP
	targetIP := net.ParseIP(ipAddr)
	if targetIP == nil {
		return false
	}

	// Check all units and families
	for _, unit := range iface.Units {
		for familyName, family := range unit.Family {
			if familyName == "inet" || familyName == "inet6" {
				for _, addr := range family.Addresses {
					// Parse CIDR address
					ip, _, err := net.ParseCIDR(addr)
					if err != nil {
						continue
					}
					if ip.Equal(targetIP) {
						return true
					}
				}
			}
		}
	}

	return false
}
